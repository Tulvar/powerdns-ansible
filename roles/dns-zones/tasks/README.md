Опишу что вообще тут проиходит, так как через неделю уже и сам не вспомню


1. Создание списка с зонами и отфильтрованными записями:
Задача называется `"Create a list with zones and filtered records"` и использует модуль `set_fact`, чтобы создать новый факт с именем `filtered_zones`.
В этой задаче происходит фильтрация записей зон, с использованием функции `json_query`. Фильтрация выполняется по атрибуту `location`, который должен быть равен значению переменной `location` или `'main'`, если `location` не определена.
Задача выполняется для каждого элемента списка `dns_zones` с использованием конструкции `loop`.
- `filtered_zones|default([])`: Это фильтр, который используется для задания значения по умолчанию переменной `filtered_zones`. Если переменная `filtered_zones` не определена или содержит пустое значение, то ей будет присвоено значение пустого списка [].
- `+ [{'zone_name': zone.name, 'records': zone.records|json_query('[?(location || main) == ' + (location|default('main')) + ']')}]`: В этом выражении к текущему значению `filtered_zones` добавляется новый элемент (словарь) с двумя ключами: `zone_name` и `records`.
  - `zone_name`: Содержит имя зоны, которое получается из переменной `zone.name` (переменная `zone` передается через `loop` и `loop_control`).
  - `records`: Содержит отфильтрованные записи зоны. Записи фильтруются с использованием функции `json_query`, которая применяется к `zone.records`. Фильтрация происходит по атрибуту `location`, который должен быть равен значению переменной `location` или `'main'`, если `location` не определена. Выражение фильтрации в json_query выглядит так: `[?(location || main) == ' + (location|default('main')) + ']`.


2. Создание списка со всеми зонами и записями, у которых атрибут `location` не определен или равен 'main':
Задача называется `"Create a list with all zones and records with location not defined or equal to 'main'"` и также использует модуль `set_fact` для создания нового факта `all_zones_records`.
Записи зон фильтруются аналогично предыдущей задаче, но с использованием другой функции `json_query`.
Задача также выполняется для каждого элемента списка `dns_zones` с использованием конструкции `loop`.
- `all_zones_records|default([])`: Здесь используется фильтр `default` для задания значения по умолчанию переменной `all_zones_records`. Если переменная `all_zones_records` не была определена или её значение пусто, то она получит значение пустого списка [].
- `+ [{'zone_name': zone.name, 'records': zone.records|json_query(\"[?location == 'main' || !location]\")}]`: В этом выражении к текущему значению all_zones_records добавляется новый элемент (словарь) с двумя ключами: `zone_name` и `records`.
  - `zone_name`: Содержит имя зоны, которое получается из переменной zone.name (переменная zone передается через `loop` и `loop_control`).
  - `records`: Содержит отфильтрованные записи зоны. Записи фильтруются с помощью функции json_query, применяемой к zone.`records`. Фильтрация происходит по атрибуту `location`, который должен быть равен `'main'` или не быть определенным вовсе. Выражение фильтрации в `json_query` выглядит так: `[?location == 'main'`

3. Слияние списков `filtered_zones` и `all_zones_records` с удалением дубликатов:
Задача называется `"Merge filtered_zones and all_zones_records and remove duplicates"` и использует модуль `set_fact` для создания нового факта `merged_zones`.
В данной задаче происходит слияние двух списков, а также удаление дубликатов записей с использованием функций `rejectattr` и `map`.
Задача выполняется с использованием конструкции `with_together`, которая позволяет итерироваться одновременно по двум спискам.
Все задачи содержат `no_log: true`, что означает, что результаты выполнения этих задач не будут записываться в журналы.

- `merged_zones`: `"{{ merged_zones|default([]) + [{'zone_name': item.0.zone_name, 'records': _unique_records}] }}"`: Здесь создается или обновляется переменная `merged_zones`, которая получает значение из предыдущего `merged_zones` (или пустой список, если `merged_zones` не определен) плюс новый элемент (словарь), включающий `zone_name` и `records`. `zone_name` берется из первого элемента текущей итерации `(item.0.zone_name)`, а `records` берется из переменной `_unique_records`.

- vars: Здесь определяются две переменные - `_filtered_records_set` и `_unique_records`.

  - `_filtered_records_set`: `"{{ item.1.records|map(attribute='name')|list }}"`: Эта переменная создает список имен записей из второго элемента текущей итерации `(item.1.records)`.
  - `_unique_records`: `"{{ item.0.records|rejectattr('name', 'in', _filtered_records_set)|list + item.1.records }}"`: Эта переменная создает список уникальных записей. Сначала из первого элемента текущей итерации `(item.0.records)` удаляются все записи, имена которых присутствуют в `_filtered_records_set`, затем к оставшемуся списку добавляются все записи из второго элемента текущей итерации `(item.1.records)`.
- `with_together`: - `"{{ all_zones_records }}" - "{{ filtered_zones }}"`: Это конструкция для одновременной итерации по двум спискам. В каждой итерации `item.0` будет элементом из `all_zones_records`, а `item.1` - элементом из `filtered_zones`.
